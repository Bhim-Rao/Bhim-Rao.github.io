[
	{
		"name": "Conway's Game of Life",
		"description": "Understanding how Conway's game of life and other cellular automata work",
		"content" : "## Game of life algorithm\nThe game of life takes place in an infinite two dimensional grid of cells. However in this implementation the grid is finite. A cell can be alive or dead which can also be called populated and unpopulated. every cell relates to 8 of it's direct neighbors.\n<div id=\"cen\">\n<img src=\"assets/imgs/grid.png\" alt=\"drawing\" width=\"200\" text-align=\"center\"/>\n</div>\n\n### Rules:\n\n- if the cell is alive and has < 2 live neighbors it dies\n- if the cell is alive and has exactly 2 or 3 live neighbors it lives\n- if the cell is alive and has more than 3 neighbors it dies\n- if the cell is dead and has exactly 3 neighbors it becomes alive"
	},
	{
		"name": "Sand Simulation",
		"description": "Understanding how Conway's game of life and other cellular automata work",
		"content" : "## Sand Algorithm\nThe simulation uses a grid of cells that are either filled (by sand) or empty. The algorithm iterates through every cell and if the cell is filled the program goes through some checks.\n<div align=\"center\">\n  <img src=\"assets/imgs/grid2.png\" alt=\"drawing\" width=\"200\" text-align=\"center\" style=\"border-radius: 10%;\"/>\n</div>\n\n### Checks:\n\n- If cell 1 is empty the program empties the current cell and fills cell 1\n- Else if cell 2 is empty the program empties the current cell and fills cell 2\n- Else if cell 3 is empty the program empties the current cell and fills cell 3\n- Else the current cell stays filled"
	},
	{
		"name": "The Traveling Salesman Problem",
		"description": "Examinining the traveling salesman problem and some of it's popular solutions",
		"content": "The Traveling Salesman Problem is a problem used to test computational optimization.\n\n## Setup\ngiven a list of cities (we can look at them as positions on a 2d grid) and the distance between each city (calculated during runtime using the pythagorean theorem) find the shortest path that goes through every point once and returns back to the original point.\n\n## Solutions\n### Brute Force\n    -    This is the Most basic method and it's incredibly inefficient\n    -    We can calculate how long it'll take to run the algorithm by finding how many permutations there are using (1/2(n-1)!) with 20 cities it would be 60,822,550,204,416,000 permutations. if we assume that it will take 0.5 milliseconds for each permutation, it would take around 964,335.2 years to run every possible path.\n### Branch and Bound\n    -    This is a slightly more efficient algorithm but it's still fairly inefficient\n    -   it start's by checking the distance from the \"origin\" city to all the other cities. The Algorithm takes the city that is the closest and repeats the algorithm excluding all the cities that have already been checked. This recurses until all the cities have been checked."
	}
]
